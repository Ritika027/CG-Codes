#include <GL/glut.h>
#include <iostream>
#include <cmath>
using namespace std;

int polyX[100], polyY[100], count = 0;
bool polygonComplete = false;
int fillType = 0;

void setPixel(int x, int y, float r, float g, float b) {
    glColor3f(r, g, b);
    glBegin(GL_POINTS);
    glVertex2i(x, y);
    glEnd();
    glFlush();
}

bool colorsMatch(float *a, float *b) {
    float epsilon = 0.01;
    return fabs(a[0] - b[0]) < epsilon && fabs(a[1] - b[1]) < epsilon && fabs(a[2] - b[2]) < epsilon;
}

void getPixelColor(int x, int y, float *color) {
    glReadPixels(x, y, 1, 1, GL_RGB, GL_FLOAT, color);
}

void boundaryFill(int x, int y, float *fill, float *boundary) {
    float current[3];
    getPixelColor(x, y, current);
    if (!colorsMatch(current, boundary) && !colorsMatch(current, fill)) {
        setPixel(x, y, fill[0], fill[1], fill[2]);
        boundaryFill(x + 1, y, fill, boundary);
        boundaryFill(x - 1, y, fill, boundary);
        boundaryFill(x, y + 1, fill, boundary);
        boundaryFill(x, y - 1, fill, boundary);
    }
}

void seedFill(int x, int y, float *fill, float *oldColor) {
    float current[3];
    getPixelColor(x, y, current);
    if (colorsMatch(current, oldColor)) {
        setPixel(x, y, fill[0], fill[1], fill[2]);
        seedFill(x + 1, y, fill, oldColor);
        seedFill(x - 1, y, fill, oldColor);
        seedFill(x, y + 1, fill, oldColor);
        seedFill(x, y - 1, fill, oldColor);
    }
}

void mouse(int btn, int state, int x, int y) {
    y = 480 - y;
    if (btn == GLUT_LEFT_BUTTON && state == GLUT_DOWN) {
        if (!polygonComplete) {
            polyX[count] = x;
            polyY[count] = y;
            count++;
            setPixel(x, y, 1, 1, 1);
        } else {
            float fill[3] = {0.0, 1.0, 0.0};
            float border[3] = {1.0, 1.0, 1.0};
            float oldColor[3];
            getPixelColor(x, y, oldColor);
            if (fillType == 1) seedFill(x, y, fill, oldColor);
            else if (fillType == 2) boundaryFill(x, y, fill, border);
        }
    }
}

void keyboard(unsigned char key, int x, int y) {
    if (key == 13 && count > 2) {
        glColor3f(1, 1, 1);
        glBegin(GL_LINE_LOOP);
        for (int i = 0; i < count; i++)
            glVertex2i(polyX[i], polyY[i]);
        glEnd();
        glFlush();
        polygonComplete = true;
    } else if (key == 'r' || key == 'R') {
        count = 0;
        polygonComplete = false;
        glClear(GL_COLOR_BUFFER_BIT);
        glFlush();
    }
}

void menu(int id) {
    fillType = id;
}

void init() {
    glClearColor(0, 0, 0, 0);
    glClear(GL_COLOR_BUFFER_BIT);
    gluOrtho2D(0, 640, 0, 480);
}

void display() {}

int main(int argc, char **argv) {
    glutInit(&argc, argv);
    glutInitWindowSize(640, 480);
    glutInitDisplayMode(GLUT_SINGLE | GLUT_RGB);
    glutCreateWindow("Polygon Fill - Seed & Boundary");
    init();
    glutDisplayFunc(display);
    glutMouseFunc(mouse);
    glutKeyboardFunc(keyboard);
    glutCreateMenu(menu);
    glutAddMenuEntry("Seed Fill", 1);
    glutAddMenuEntry("Boundary Fill", 2);
    glutAttachMenu(GLUT_RIGHT_BUTTON);
    glutMainLoop();
    return 0;
}
