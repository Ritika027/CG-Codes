

#include <GL/glut.h>
#include <iostream>
#include <cmath>
using namespace std;

int polyX[100], polyY[100], count = 0;     //Polygon ke 100 tak ke points store karne ke liye x & y arrays.count polygon ke points ki total.
bool polygonComplete = false;              //check karta hai polygon ban gaya hai ya nahi
int fillType = 0;                          //1 = Seed Fill, 2 = Boundary Fill.

void setPixel(int x, int y, float r, float g, float b) {
    glColor3f(r, g, b);      // Drawing color set karo
    glBegin(GL_POINTS);      // Pixel draw karna start karo
    glVertex2i(x, y);        // Us point ki location
    glEnd();                 // Drawing complete
    glFlush();               // Output ko forcefully screen pe dikhaye
}


bool colorsMatch(float *a, float *b) { //Compares two colors with a small margin (epsilon) because float values exact match nahi karte generally.
    float epsilon = 0.01;
    return fabs(a[0] - b[0]) < epsilon && fabs(a[1] - b[1]) < epsilon && fabs(a[2] - b[2]) < epsilon;
}

void getPixelColor(int x, int y, float *color) {
    glReadPixels(x, y, 1, 1, GL_RGB, GL_FLOAT, color);
}

// Boundary Fill Algorithm – border se match na kare toh fill karo
void boundaryFill(int x, int y, float *fill, float *boundary) {
    float current[3];
    getPixelColor(x, y, current);
    if (!colorsMatch(current, boundary) && !colorsMatch(current, fill)) {
        setPixel(x, y, fill[0], fill[1], fill[2]);
        boundaryFill(x + 1, y, fill, boundary);
        boundaryFill(x - 1, y, fill, boundary);
        boundaryFill(x, y + 1, fill, boundary);
        boundaryFill(x, y - 1, fill, boundary);
    }
}

// Seed Fill Algorithm – agar current color old color jaisa hai toh fill karo
void seedFill(int x, int y, float *fill, float *oldColor) {
    float current[3];
    getPixelColor(x, y, current);
    if (colorsMatch(current, oldColor)) {
        setPixel(x, y, fill[0], fill[1], fill[2]);
        seedFill(x + 1, y, fill, oldColor);
        seedFill(x - 1, y, fill, oldColor);
        seedFill(x, y + 1, fill, oldColor);
        seedFill(x, y - 1, fill, oldColor);
    }
}

void mouse(int btn, int state, int x, int y) {
    y = 480 - y;
    if (btn == GLUT_LEFT_BUTTON && state == GLUT_DOWN) {
        if (!polygonComplete) {
            polyX[count] = x;
            polyY[count] = y;
            count++;
            setPixel(x, y, 1, 1, 1); // White point
        } else {
            float fill[3] = {0.0, 1.0, 0.0};      // Green
            float border[3] = {1.0, 1.0, 1.0};    // White
            float oldColor[3];
            getPixelColor(x, y, oldColor);
            if (fillType == 1) seedFill(x, y, fill, oldColor);
            else if (fillType == 2) boundaryFill(x, y, fill, border);
        }
    }
}

void keyboard(unsigned char key, int x, int y) {
    if (key == 13 && count > 2) { // Enter key
        glColor3f(1, 1, 1); // White polygon
        glBegin(GL_LINE_LOOP);
        for (int i = 0; i < count; i++)
            glVertex2i(polyX[i], polyY[i]);
        glEnd();
        glFlush();
        polygonComplete = true;
    }
}

void menu(int id) {
    fillType = id;
}

void init() {
    glClearColor(0, 0, 0, 0); // Black background
    glClear(GL_COLOR_BUFFER_BIT);
    gluOrtho2D(0, 640, 0, 480);
}

void display() {}

int main(int argc, char **argv) {
    glutInit(&argc, argv);
    glutInitWindowSize(640, 480);
    glutInitDisplayMode(GLUT_SINGLE | GLUT_RGB);
    glutCreateWindow("Polygon Fill - Seed & Boundary");
    init();
    glutDisplayFunc(display);
    glutMouseFunc(mouse);
    glutKeyboardFunc(keyboard);
    glutCreateMenu(menu);
    glutAddMenuEntry("Seed Fill", 1);
    glutAddMenuEntry("Boundary Fill", 2);
    glutAttachMenu(GLUT_RIGHT_BUTTON);
    glutMainLoop();
    return 0;
}